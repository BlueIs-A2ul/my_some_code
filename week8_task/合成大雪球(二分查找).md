### 一：小刘的最短路(模拟)



### 题目链接：[[A-小刘的最短路_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/A)]



#### 题目描述：



小刘在找Susan，她准备去找Jerry问一下Susan在哪。（以下Jerry简称Y，Susan简称N） 寻找过程：找到，将N带回Y的位置，可以简单的理解为先找到N再去找Y。 我们把寻找过程简化为一条数轴，小刘在数轴上的坐标为0,**Y**在数轴上的坐标为y，**N**在数轴上的坐标为n。初始时小刘只知道Y的坐标，而不知道N的坐标，因此小刘会先前往Y的坐标。而当小刘到达Y的坐标时，就可以知道N的坐标。 小刘的视野为k，若小刘当前坐标为u，则她可以看到[][u - k, u + k][u−k,u+k]区间内的东西，即小刘可能可以在移动到Y所在坐标的过程中直接看到N，去找到N，省略先去找Y的过程。 小刘想知道她将N带回Y的坐标最少需要移动多少距离。 

#### 输入描述

输入三个整数y,n(−109≤y,n≤109),k(1≤k≤109)

#### 输出描述

输出一个整数表示答案。

#### 用例输入 1



```cpp
3 2 1
```



#### 用例输出 1



```cpp
3
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
using namespace std;
int y, n, k;
signed main()
{
    cin >> y >> n >> k; // 先去到y的坐标，再去到n的坐标
    // k作为视野范围,
    if (y * n >= 0)//在同一侧
    {
        if(abs(y) > abs(n)) {
            cout << abs(y) << endl;
            return 0;
        }
        else {
            cout << abs(n) + abs (y-n)<< endl;
            return 0;
        }
    }
    //在两侧
    int diff = abs(y) + abs(n); // 两点的距离
    if (abs(n) > k)
    {
        cout << 2 * diff + abs(y) << endl;
        return 0;
    }
    cout << diff + abs(n) << endl;
    return 0;
}
```



### 解题思路：

这道题目本身在代码上比较简单，主要是本身逻辑关系。我们可以分为以下几种情况：(我们通过取绝对值的方式，全部化为非负半轴来讨论)

1.y和n在原点的同一侧，此后又分为两种情况：

​		1)y比n更远离原点，这个时候不论k的大小，在u去找y的过程中，必定会先看到n，所以就相当于直接去到y点

​		2)y比n更靠近原点，这个时候同样是不论k的大小，一定是先到y再到n，再回到n，故距离是abs(n) + abs (y-n)

2.y和n在原点的两侧，

​		1)k足够大到在原点就可以看到n，这个时候必定是先去找n再去找y

​		2)如果k比较小，这时候由于在原点两侧，u只会离n越来越远，故一定是在找到y以后才能得知n的坐标，那么距离就是2 * diff + abs(y)

#### 问题与反思：

1.分类讨论比较复杂，但是逻辑捋清楚了其实不难

2.对k的处理要适当

### 二：建造新家(数学方法化简目标)



### 题目链接：[[B-建造新家_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/B)]



#### 题目描述：

链接：https://ac.nowcoder.com/acm/contest/98528/B
来源：牛客网

小蕊学姐是一个喜欢挑战的人，她想要在森林里面建造一个新家，但是森林里面危机四伏。这里面有n个猛兽（从1到n进行编号），第i个猛兽的危险系数为ai。她想要驯服一个猛兽作为自己的宠物来保护自己，现在定义第i个猛兽的危险度为
$$
f\left ( i \right ) = \left ( x-i \right ) ^2 * a
$$
其中x为驯服的猛兽序号。现在请你帮小蕊学姐选一个猛兽，使得危险度的总和最小

#### 输入描述

$$
第一行 \ \ \ 一个正整数\ n\ 表示猛兽的个数（

1\le n  \le10^5

）\\
第二行 \ \ \ n个正整数\ \ a_{i}表示第\ i \ 个正整数的危险系数(0 \le a_i \le 10^{4})
$$

#### 输出描述

一个自然数，表示最小的危险度之和

#### 用例输入 1



```cpp
5
7 3 1 6 5
```



#### 用例输出 1



```cpp
57
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
using namespace std;
vector<int> v;
vector<int> sum;
int s1, s2, s3;
signed main()
{
    int n;
    cin >> n;
    Ir(i, 0, n)
    {
        int x;
        cin >> x;
        v.push_back(x);
        s1 += x;
        s2 += (i + 1) * x;
        s3 += (i + 1) * (i + 1) * x;
    }
    Ir(i, 0, n)
    {
        sum.push_back((i + 1) * (i + 1) * s1 - 2 * (i + 1) * s2 + s3);
    }
    int mini = min(sum[0], sum[n - 1]);
    Ir(i, 1, n - 1)
    {
        mini = min(mini, sum[i]);
    }
    cout << mini << endl;
    return 0;
}

```



### 解题思路：

有点意外的数学题，按直接遍历来做一定会涉及到两个for循环，那么时间复杂度就会到O(N^2)。

在这里有一个数学上的化简，如果对于第x个数，我们将危险度综合定义为sum[x];有下列化简
$$
由于f\left ( i \right ) = \left ( x-i \right ) ^2 * a_{i}\\
\begin{align}
故sum[x] &= \sum_{i=1}^{len}[\hspace{5pt}\left( x-i\right)^2*s[i]\hspace{5pt}]\\
&=\sum_{i=1}^{len}(x^2*s[i]+i^2*s[i]-2x*i*s[i])\\
&=x^2*\sum_{i=1}^{len}s[i] + \sum_{i=1}^{len}(i^2 * s[i]) -2*x *\sum_{i=1}^{len}(i*s[i])
\end{align}
$$
以上这些特殊的和均可以在完成输入时计算，不必在遍历计算，只需遍历x的值建立sum[x]与x的关系输出最小值即可

#### 问题与反思：

1.实际思路有点类似于高中关于线性回归方程系数的转换，没见过真的想不到



### 三：合成大雪球(二分查找)



### 题目链接：[[C-合成大雪球_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/C)]



#### 题目描述：

打雪仗时把两个不同的小雪球合成一个大雪球扔出去，这样雪球就具有更高的威力(砸人身上更疼,bushi）。
 以前一到过年下雪，sxh就会约小伙伴去打雪仗。
 回想某次过年，sxh当时手中还剩下 n 个小雪球，其体积分别为 v1​,v2​,…,vn​。两个体积分别为 x 和 y 的小雪球可以合成一个体积为x+y 的大雪球。他想知道所有的合成方案中，体积第 k 小的大雪球的体积是多少。两个合成方案不同当且仅当至少一个小雪球的序号不同。

#### 输入描述

测试点包含多组数据。第一行包含一个整数 T（1≤T≤10），表示数据组数。每组数据的输入格式如下：

第一行包含一个整数 n（2≤n≤105），表示小雪球的个数。

第二行包含 n个整数v1,v2,…,vn（1≤vi≤109），分别表示每个小雪球的体积。

第三行包含一个整数 k（1≤k≤n(n−1)/2），表示询问，其含义已在上文给出。

#### 输出描述

每组数据包含一个整数，表示体积第 k小的大雪球的体积。

#### 用例输入 1

```
1
4
2 3 4 5
3
```



#### 用例输出 1



```
7
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long 
#define Ir(i, a, b) for (int i = a; i < b; i++)
using namespace std;
vector<int> nums;
int findKthNumber(vector<int> &nums, int k)
{
    sort(nums.begin(), nums.end()); // 对数组进行排序
    int n = nums.size();

    // 定义辅助函数，用于统计和小于等于给定值的组合数量
    auto countPairs = [&](int limit)
    {
        int count = 0;
        int left = 0, right = n - 1;
        while (left < right){
            if (nums[left] + nums[right] <= limit){
                count += right - left; // 由于数组已排序，可以直接加上right-left个组合
                left++;                // 移动左指针以尝试更大的和
            }
            else{
                right--; // 移动右指针以尝试更小的和
            }
        }
        return count;
    };

    // 二分查找的上下界
    int left = nums[0] + nums[1];
    int right = nums[n - 1] + nums[n - 2];

    // 二分查找第k小的和
    while (left < right){
        int mid = left + (right - left) / 2;
        if (countPairs(mid) < k){
            left = mid + 1; // 如果小于k个和小于等于mid，则第k小的和一定在mid的右侧
        }
        else{
            right = mid; // 如果大于等于k个和小于等于mid，则第k小的和可能在mid的左侧或就是mid本身
        }
    }
    // 当二分查找结束时，left == right，此时left（或right）就是第k小的和
    return left;
}

signed main(){
    int n;
    cin >> n;
    while (n--){
        int n1;
        cin >> n1;
        nums.clear();//清除每次的动态数组
        Ir(i, 0, n1){
            int x;
            cin >> x;
            nums.push_back(x);
        }
        int k;
        cin >> k;
        cout << findKthNumber(nums, k) << endl;
    }
    return 0;
}
```



### 解题思路：







#### 问题与反思：

### 四：羽毛球比赛



### 题目链接：[[D-羽毛球比赛_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/D)]



#### 题目描述：

SWPU校羽毛球比赛一共有n名同学参加，第i号选手截至目前已经积了ai 分，其中一号选手是zhy。

 接下来将还有m场比赛要进行，第i场比赛的对阵双方是编号为ui​和vi​的同学
 积分规则是：胜方加三分，败方不得分，若战平则双方各得一分。

 请你预测一下在最好的情况下，我们的一号选手zhy能够排到第几名。

 注意若有多同学并列，则排名取并列的排名，且不影响随后的排名（例如两个人并列第二名，则都视为第二名，排名其后的下一一个同学视为第四名）。

#### 输入描述

输入第一行包括一个整数T(1≤T≤100)，样例组数。

对于每组样例：
第一行输入两个整数n,m(2≤n≤10,1≤m≤10)，含义如题面所述。

第二行输入n个整数 (0≤ai≤100)，表示第i名同学当前已经有的积分。

接下来的m行，每行有两个正整数v,u表示i场比赛的对阵双方

#### 输出描述

对每组样例，输出一个整数表示一号选手最好的情况下能够排到第几名。

#### 用例输入 1



```cpp
3
    
4 3
2 4 5 8
1 2
1 4
2 4
    
3 1
3 1 1
2 3
    
6 6
1 2 3 4 5 6
2 3
2 3
3 4
4 5
5 6
6 1
```



#### 用例输出 1



```cpp
1
1
4
```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：

### 五：小青找宝藏



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：





### 七：左移(字符串)



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：



### 八：深渊图书馆



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：

### 九：空间挪移



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：



### 十：逃离节奏面



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：

### 十一：赚差价



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：



### 十二：编辑器



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：

### 十三：切多边形



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：











