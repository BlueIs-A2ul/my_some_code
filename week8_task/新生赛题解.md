### 一：小刘的最短路(模拟)



### 题目链接：[[A-小刘的最短路_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/A)]



#### 题目描述：



小刘在找Susan，她准备去找Jerry问一下Susan在哪。（以下Jerry简称Y，Susan简称N） 寻找过程：找到，将N带回Y的位置，可以简单的理解为先找到N再去找Y。 我们把寻找过程简化为一条数轴，小刘在数轴上的坐标为0,**Y**在数轴上的坐标为y，**N**在数轴上的坐标为n。初始时小刘只知道Y的坐标，而不知道N的坐标，因此小刘会先前往Y的坐标。而当小刘到达Y的坐标时，就可以知道N的坐标。 小刘的视野为k，若小刘当前坐标为u，则她可以看到[][u - k, u + k][u−k,u+k]区间内的东西，即小刘可能可以在移动到Y所在坐标的过程中直接看到N，去找到N，省略先去找Y的过程。 小刘想知道她将N带回Y的坐标最少需要移动多少距离。 

#### 输入描述

输入三个整数y,n(−109≤y,n≤109),k(1≤k≤109)

#### 输出描述

输出一个整数表示答案。

#### 用例输入 1



```cpp
3 2 1
```



#### 用例输出 1



```cpp
3
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
using namespace std;
int y, n, k;
signed main()
{
    cin >> y >> n >> k; // 先去到y的坐标，再去到n的坐标
    // k作为视野范围,
    if (y * n >= 0)//在同一侧
    {
        if(abs(y) > abs(n)) {
            cout << abs(y) << endl;
            return 0;
        }
        else {
            cout << abs(n) + abs (y-n)<< endl;
            return 0;
        }
    }
    //在两侧
    int diff = abs(y) + abs(n); // 两点的距离
    if (abs(n) > k)
    {
        cout << 2 * diff + abs(y) << endl;
        return 0;
    }
    cout << diff + abs(n) << endl;
    return 0;
}
```



### 解题思路：

这道题目本身在代码上比较简单，主要是本身逻辑关系。我们可以分为以下几种情况：(我们通过取绝对值的方式，全部化为非负半轴来讨论)

1.y和n在原点的同一侧，此后又分为两种情况：

​		1)y比n更远离原点，这个时候不论k的大小，在u去找y的过程中，必定会先看到n，所以就相当于直接去到y点

​		2)y比n更靠近原点，这个时候同样是不论k的大小，一定是先到y再到n，再回到n，故距离是abs(n) + abs (y-n)

2.y和n在原点的两侧，

​		1)k足够大到在原点就可以看到n，这个时候必定是先去找n再去找y

​		2)如果k比较小，这时候由于在原点两侧，u只会离n越来越远，故一定是在找到y以后才能得知n的坐标，那么距离就是2 * diff + abs(y)

#### 问题与反思：

1.分类讨论比较复杂，但是逻辑捋清楚了其实不难

2.对k的处理要适当

### 二：建造新家(数学方法化简目标)



### 题目链接：[[B-建造新家_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/B)]



#### 题目描述：

链接：https://ac.nowcoder.com/acm/contest/98528/B
来源：牛客网

小蕊学姐是一个喜欢挑战的人，她想要在森林里面建造一个新家，但是森林里面危机四伏。这里面有n个猛兽（从1到n进行编号），第i个猛兽的危险系数为ai。她想要驯服一个猛兽作为自己的宠物来保护自己，现在定义第i个猛兽的危险度为
$$
f\left ( i \right ) = \left ( x-i \right ) ^2 * a
$$
其中x为驯服的猛兽序号。现在请你帮小蕊学姐选一个猛兽，使得危险度的总和最小

#### 输入描述

$$
第一行 \ \ \ 一个正整数\ n\ 表示猛兽的个数（

1\le n  \le10^5

）\\
第二行 \ \ \ n个正整数\ \ a_{i}表示第\ i \ 个正整数的危险系数(0 \le a_i \le 10^{4})
$$

#### 输出描述

一个自然数，表示最小的危险度之和

#### 用例输入 1



```cpp
5
7 3 1 6 5
```



#### 用例输出 1



```cpp
57
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
using namespace std;
vector<int> v;
vector<int> sum;
int s1, s2, s3;
signed main()
{
    int n;
    cin >> n;
    Ir(i, 0, n)
    {
        int x;
        cin >> x;
        v.push_back(x);
        s1 += x;
        s2 += (i + 1) * x;
        s3 += (i + 1) * (i + 1) * x;
    }
    Ir(i, 0, n)
    {
        sum.push_back((i + 1) * (i + 1) * s1 - 2 * (i + 1) * s2 + s3);
    }
    int mini = min(sum[0], sum[n - 1]);
    Ir(i, 1, n - 1)
    {
        mini = min(mini, sum[i]);
    }
    cout << mini << endl;
    return 0;
}

```



### 解题思路：

有点意外的数学题，按直接遍历来做一定会涉及到两个for循环，那么时间复杂度就会到O(N^2)。

在这里有一个数学上的化简，如果对于第x个数，我们将危险度综合定义为sum[x];有下列化简
$$
由于f\left ( i \right ) = \left ( x-i \right ) ^2 * a_{i}\\
\begin{align}
故sum[x] &= \sum_{i=1}^{len}[\hspace{5pt}\left( x-i\right)^2*s[i]\hspace{5pt}]\\
&=\sum_{i=1}^{len}(x^2*s[i]+i^2*s[i]-2x*i*s[i])\\
&=x^2*\sum_{i=1}^{len}s[i] + \sum_{i=1}^{len}(i^2 * s[i]) -2*x *\sum_{i=1}^{len}(i*s[i])
\end{align}
$$
以上这些特殊的和均可以在完成输入时计算，不必在遍历计算，只需遍历x的值建立sum[x]与x的关系输出最小值即可

#### 问题与反思：

1.实际思路有点类似于高中关于线性回归方程系数的转换，没见过真的想不到



### 三：合成大雪球(二分查找)



### 题目链接：[[C-合成大雪球_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/C)]



#### 题目描述：

打雪仗时把两个不同的小雪球合成一个大雪球扔出去，这样雪球就具有更高的威力(砸人身上更疼,bushi）。
 以前一到过年下雪，sxh就会约小伙伴去打雪仗。
 回想某次过年，sxh当时手中还剩下 n 个小雪球，其体积分别为 v1​,v2​,…,vn​。两个体积分别为 x 和 y 的小雪球可以合成一个体积为x+y 的大雪球。他想知道所有的合成方案中，体积第 k 小的大雪球的体积是多少。两个合成方案不同当且仅当至少一个小雪球的序号不同。

#### 输入描述

测试点包含多组数据。第一行包含一个整数 T（1≤T≤10），表示数据组数。每组数据的输入格式如下：

第一行包含一个整数 n（2≤n≤105），表示小雪球的个数。

第二行包含 n个整数v1,v2,…,vn（1≤vi≤109），分别表示每个小雪球的体积。

第三行包含一个整数 k（1≤k≤n(n−1)/2），表示询问，其含义已在上文给出。

#### 输出描述

每组数据包含一个整数，表示体积第 k小的大雪球的体积。

#### 用例输入 1

```
1
4
2 3 4 5
3
```



#### 用例输出 1



```
7
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long 
#define Ir(i, a, b) for (int i = a; i < b; i++)
using namespace std;
vector<int> nums;
int findKthNumber(vector<int> &nums, int k)
{
    sort(nums.begin(), nums.end());
    int n = nums.size();

    // 定义辅助函数，用于统计和小于等于给定值的组合数量
    auto countPairs = [&](int limit)
    {
        int count = 0;
        int left = 0, right = n - 1;
        while (left < right){
            if (nums[left] + nums[right] <= limit){
                count += right - left; // 由于数组已排序，可以直接加上right-left个组合
                //在这里，因为当前的nums[left] + nums[right]已经满足小于等于limit的要求
                //并且在数组已经排序的情况下，我们可以知道，对于满足left<=i<=right的索引i
                //nums[left] + nums [i]是一定<=limit的
                //因此我们不用再做继续下去的计算，只需计算差值后，移动left即可
                left ++;   
                // 移动左指针以尝试更大的和
            }
            else{
                right--; // 移动右指针以尝试更小的和
            }
        }
        return count;
    };

    // 二分查找的上下界
    int left = nums[0] + nums[1];
    int right = nums[n - 1] + nums[n - 2];

    // 二分查找第k小的和
    while (left < right){
        int mid = left + (right - left) / 2;
        if (countPairs(mid) < k){
            left = mid + 1; // 如果小于k个和小于等于mid，则第k小的和一定在mid的右侧
        }
        else{
            right = mid; // 如果大于等于k个和小于等于mid，则第k小的和可能在mid的左侧或就是mid本身
        }
    }
    // 当二分查找结束时，left == right，此时left（或right）就是第k小的和
    return left;
}

signed main(){
    int n;
    cin >> n;
    while (n--){
        int n1;
        cin >> n1;
        nums.clear();//清除每次的动态数组
        Ir(i, 0, n1){
            int x;
            cin >> x;
            nums.push_back(x);
        }
        int k;
        cin >> k;
        cout << findKthNumber(nums, k) << endl;
    }
    return 0;
}
```

### 解题思路：

总的来说是双指针和二分查找的结合，用双指针来计算对于数组任意两个元素的和小于等于某个值的组合数量，再利用二分查找在可能的和的范围内逼近第k小的和。下面是具体实现过程：
1.双指针，因为我们已经将数组排序，所以可以利用双指针从`left`和`right`开始移动，其实不管移动哪边效果应该是一样的，我们以`left`为基准，在和大于`limit`时`right`向左移动，这样会使得和更小。在符合条件时计算组合的数目， 由于数组已排序，可以直接加上`right-left`个组合，在这里，`因为当前的nums[left] + nums[right]已经满足小于等于limit的要求`。并且在数组已经排序的情况下，我们可以知道，对于满足left<=i<=right的索引 i，`nums[left] + nums [i`]是一定`<=limit`的，因此我们不用再做继续下去的计算，只需计算差值后，移动`left`继续寻找以下一个为`left`为基准实现的和小于`limit`(此时的`Nums[left]`变得更大，需要`righ`t继续左移才能满足)

2.二分查找，在这里我们就是要通过二分找到刚好组合数为k的mid，`如果当前mid使得组合数多于k，说明mid是偏大的，因为我们的函数实现的是计算小于等于mid的组合数量`，mid越大组合数就该越多，在mid偏大的情况我们就要以mid左边为新区间更新mid，相反就应该在mid右边为新区间更新mid，直至这个mid刚刚好使得组合数为k。

#### 问题与反思：

1.~~早知道暴力也可以过我就暴力了~~

2.没见过这种把二分和双指针结合起来的，并且在某种角度也体现了，虽然我们在这里需要用到两个元素的和，但也不一定非要去算每两个元素的和，只是查找。

### 四：羽毛球比赛(深度优先搜索)



### 题目链接：[[D-羽毛球比赛_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/D)]



#### 题目描述：

SWPU校羽毛球比赛一共有n名同学参加，第i号选手截至目前已经积了ai 分，其中一号选手是zhy。

 接下来将还有m场比赛要进行，第i场比赛的对阵双方是编号为ui​和vi​的同学
 积分规则是：胜方加三分，败方不得分，若战平则双方各得一分。

 请你预测一下在最好的情况下，我们的一号选手zhy能够排到第几名。

 注意若有多同学并列，则排名取并列的排名，且不影响随后的排名（例如两个人并列第二名，则都视为第二名，排名其后的下一一个同学视为第四名）。

#### 输入描述

输入第一行包括一个整数T(1≤T≤100)，样例组数。

对于每组样例：
第一行输入两个整数n,m(2≤n≤10,1≤m≤10)，含义如题面所述。

第二行输入n个整数 (0≤ai≤100)，表示第i名同学当前已经有的积分。

接下来的m行，每行有两个正整数v,u表示i场比赛的对阵双方

#### 输出描述

对每组样例，输出一个整数表示一号选手最好的情况下能够排到第几名。

#### 用例输入 1



```cpp
3
    
4 3
2 4 5 8
1 2
1 4
2 4
    
3 1
3 1 1
2 3
    
6 6
1 2 3 4 5 6
2 3
2 3
3 4
4 5
5 6
6 1
```



#### 用例输出 1



```cpp
1
1
4
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
#define DG(x) cout << #x << " = " << x << endl;

#define MAXN 100005
using namespace std;

pair<int, int> obj[11];//存放每次的对战情况
int pla[11];//选手对应的分数
int min0 = 1e18;//最好名次
int T;
int n, m, k;

void dfs(int pos)
{
    if (pos == m + 1)
    {
        int num = 1;//先假设是第一名
        Ip(i, 2, n)
        {
            if (pla[i] > pla[1])
                num++;//选手i比选手1好
        }
        min0 = min(min0, num);
        return ;
    }

    int p[3] = {3, 0, 1};
    int q[3] = {0, 3, 1};
    //胜or负or平的三种情况

    Ir(i, 0, 3)
    {
        pla[obj[pos].first] += p[i];
        pla[obj[pos].second] += q[i];
        dfs(pos + 1);//遍历每一种胜负的情况

        pla[obj[pos].first] -= p[i];
        pla[obj[pos].second] -= q[i];
        //恢复原状态
    }
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> T;
    while (T--)
    {
        cin >> n >> m;

        Ip(i, 1, n) cin >> pla[i];
        Ip(i, 1, m) cin >> obj[i].first >> obj[i].second;
        dfs(1);

        cout << min0 << endl;
        min0 = 1e18;
    }
}

```



### 解题思路：

这个题理应存在两种思路

1.深度优先搜索，将每次对战的每次胜负的每一种情况都利用深度优先处理，在情况列举完成后，通过对比，取得不同情况下最优的名次。

2.一种类似于贪心的想法，因为我们希望一号选手的名次最高，所以如果有一号选手参赛的情况，一号选手必须要赢，如果一号选手不参赛的时候，我们就应该让分数本身低于一号的选手的分数继续保持低于的情况，以此局部最优来实现全局最优

#### 问题与反思：

1.贪心的思路本身有点反直觉，所以在顺序处理上也有不同，必须要先将有一号参赛的对战处理，并认为这些比赛一号全胜

### 五：小青找宝藏



### 题目链接：[[E-小青找宝藏_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/E)]



#### 题目描述：

在风景如画的西南石油大学校园里，小青是一位热爱数学与编程的学子。一天，她在图书馆的古籍中偶然发现了一张神秘的纸条，上面写着一个正整数 n。纸条旁边还附有一段古老的文字，提示她需要将这个数分解为三个斐波那契数之和，才能解开隐藏在校园某处的秘密宝藏。
 小青兴奋不已，决定利用自己的编程技能来完成这一挑战。然而，她很快发现，这不仅仅是一个简单的数学问题，因为纸条上还说，这样的分解方式会有 q 种不同的查询需要她一一解答。
 于是，小青决定向你求助，希望你能编写一个程序，帮助她快速准确地完成这些斐波那契数分解的任务，从而找到那些隐藏在西南石油大学各个角落的宝藏。
 题目描述
 现在，你的任务是编写一个程序，接收小青给你的 q 次查询，每次查询都包含一个正整数 n。你需要将每个 n 分解为三个斐波那契数之和，
$$
即找到三个斐波那契数 F_i,F_j,F_k​，使得n=F_i+F_j+F_k。
$$

$$
注意：斐波那契数列的定义为：F_0=0,F_1=1,F_2=1，且对于i>2，有F_i=F_{i−1}+F_{i−2}
$$

#### 输入描述

第一行输入一个整数 q，表示查询次数。
接下来 q 行，每行包含一个正整数 n，表示需要分解的正整数

#### 输出描述

对于每个查询，输出一行，包含三个整数 
$$
F_i,F_j,F_k
$$
表示将` n `分解为三个斐波那契数之和的一种方式。如果有多种分解方式，输出`F_i`最大的情况，若`F_i`相同则输出在保证`F_i`最大情况下的`F_j`最大的情况。
如果无法找到这样的三个斐波那契数，则输出 `−1`。

#### 用例输入 1



```cpp
1
3
```



#### 用例输出 1



```cpp
3 0 0
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
#define DG(x) cout << #x << " = " << x << endl;

#define MAXN 100005
using namespace std;

vector<int> fib;

int T, n;
int flag = 0;

void fib_dp()
{
    fib.push_back(0);
    fib.push_back(1);
    for (int i = 2; i < 50; i++)
    {
        fib.push_back(fib[i - 1] + fib[i - 2]);
    }
}

signed main()
{
    fib_dp();
    cin >> T;
    while (T--)
    {
        cin >> n;
        for (int i = 44; i >= 0; i--)
        {
            if ((flag == 1))
                break;
            for (int j = i; j >= 0; j--)
            {
                if (flag == 1)
                    break;
                for (int k = j; k >= 0; k--)
                {
                    if (fib[i] + fib[j] + fib[k] == n)
                    {
                        cout << fib[i] << " " << fib[j] << " " << fib[k] << endl;
                        flag = 1;
                        break;
                    }
                }
            }
        }
        if (flag == 0)
            cout << "-1\n";
    }
    return 0;
}
```



### 解题思路：

相对于题解的离线存储，实际方法是类似的，就是暴力遍历。

1) 在这里我们有一点优化，首先就是在计算fib时我们避免重复调用而是使用动态规划，当然这是很基础的
2) 其次是遍历顺序的问题，因为题中要求我们输出`F_i`最大的情况，所以我们的`for`循环并不从`i=0`开始，而是从`i=44`开始，这样我们发现的第一个可以被三个数加和得到的一定是最大的，这在数据偏大时可以比较好的优化时间
3) 我们采取`flag`作为一个标志性的变量，即是如果找到了就退出循环

#### 问题与反思：

1.由于这个题的多次遍历，实际也有一个类似于题解的思路，拿结构体存储和hash表结合，这个结构体应该存储任意两个fib数，以及这两个数的和，我们还可以将这个结构体存储到一个hash表中，在遍历时，我们只需要检验`x-fib[i]`是否存在于`hash表`中（我们使用cpp中哈希表的`.count函数`），再通过结构体输出对应的剩下两个fib数即可，这样时间复杂度应该就降到了平方级别

### 六：矩形面积(单调栈)



### 题目链接：[[F-矩形面积_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/F)]



#### 题目描述：

小小z在玩俄罗斯方块，他想知道游戏里的最大矩形面积（正方形也是矩形）

#### 输入描述



第一行n，表示有n个数（0≤n≤10^5）。

第2行连续n个数表示该点方块堆起的高度。

连续n个数范围是[][0,1e9][0,1e9]

#### 输出描述

一个数，最大矩形面积

#### 用例输入 1



```cpp
10
0 1 0 2 1 2 0 0 2 0
```



#### 用例输出 1



```cpp
3
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)

#define DG(x) cout << #x << " = " << x << endl;

using namespace std;

stack<int> st;
vector<int> v;
int wid, h, top;
int N, area = 0;

int max_area(vector<int> &v){
    int n = v.size();
    Ip(i, 0, n){
        h = (i == n) ? 0 : v[i];
        while (!st.empty() && h < v[st.top()]){
            top = st.top();
            st.pop();
            wid = (st.empty()) ? i : i - st.top() - 1;
            area = max(area, v[top] * wid);
        }
        st.push(i);
    }
    return area;
}

signed main(){
    cin >> N;
    Ir(i, 0, N){
        int x;
        cin >> x;
        v.push_back(x);
    }
    cout << max_area(v);
    return 0;
}
```



### 解题思路：

主要应用单调栈的思路，和力扣[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/description/)有相似的点。

在一般的思路中，我们可能会对每一个直方图进行向左和向右的扩展，去更新最大面积，在这里要注意的第一个点是实际上如果i可以向右到j构成矩形，那么j一定可以向左扩展到i构成矩形，所以对于每个直方图，我们只需要进行某一个方向的扩展，在这里出于顺序考虑，我们对于每个元素向左扩展。

然后就是对单调栈的考虑，我们通过单调栈的方法，如果当前的直方图高度比前一个更高，说明可以继续向后扩展，我们就将其入栈，如果出现当前高度更低，就要pop栈顶，并计算栈顶对应的面积。因为单调栈的存在，对于当前的直方图i和栈顶的差即是矩形的宽度。

#### 问题与反思：

1.两个重点：1) 实际扩展是对称的，不用双指针往中间走去看什么时候最大。2) 对于每个元素实际是一直到当前直方图小于前一个直方图时，才可能出现最大面积，否则面积就是一直扩大的，这也是为什么要用单调栈的一个原因。

2.补药递归啊，实现复杂度太高了

### 七：左移(字符串)



### 题目链接：[[G-左移_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/G)]



#### 题目描述：

在古老的魔法大陆上，有一座神秘的**符文之塔**，其中封印着传说中的**永恒之书**。据说，这本书中记载着改变世界的魔法咒语，但它被一道强大的符文锁住了。只有那些能够破解符文密码的人，才有资格打开书页，获取无尽的力量。

​		符文密码是一串神秘的文字序列 SS，被古代巫师附加了一种旋转魔法，使得整段符文可以**循环左移**。当某段符文的**开头**和**结尾符号完全相同**时，符文会释放出美丽的光芒，这被称为“符文共鸣”。只有找到符文的**最小旋转次数** dd，使符文出现“符文共鸣”，才能解开锁链。 

​		然而，符文之塔也有诅咒：如果无论如何旋转，符文都无法共鸣，破解者将永远被困于塔中。 

​		作为大陆上最杰出的冒险者和魔法研究者，你肩负起了解开符文之谜的任务。请根据符文序列的规律，找出让符文产生共鸣的最小旋转次数 dd，或者判断它是否无法共鸣。如果失败了，你将失去进入符文之塔的资格。

#### 输入描述

输出一个仅由小写字母组成的字符串`s0s1...sn−1`，其中： `1≤n≤5∗105`

#### 输出描述

输出一个整数，表示满足`f(S,d)`， 是美丽的最小非负整数 d。若不存在这样的 d，输出 -1。

#### 用例输入 1



```cpp
helloaacm
```



#### 用例输出 1



```cpp
3
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1e9
int min0 = MAXN;
int main(){
    string ss;
    cin >> ss;
    if ( ss[0] == ss[ss.size()-1]) {
        cout << 0;
        return 0;
    }
    for(int i = 0;i<ss.size()-1;i++){
        if(ss[i] == ss[i-1]){
            cout << i ;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```



### 解题思路：

如果在移动后要头尾一样，那么必须在原本就是相连的相同的字母，又因为顺序方向，可以直接从左边开始找，找到的第一对相同的字母就是符合要求的。如何根据索引即可计算长度。

#### 问题与反思：

1.

### 八：深渊图书馆



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：

### 九：空间挪移



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：



### 十：逃离节奏面



### 题目链接：[]



#### 题目描述：







#### 输入描述





#### 输出描述





#### 用例输入 1



```cpp

```



#### 用例输出 1



```cpp

```



### 解题代码：



```cpp

```



### 解题思路：







#### 问题与反思：

### 十一：赚差价(贪心)



### 题目链接：[[K-赚差价_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/K)]



#### 题目描述：

在广袤的银河系中，帝国边陲的一个偏远行星 **麦格隆 IV** 上，生活着一个机智的补给走私者——**苏向夜**。麦格隆 IV 是一颗重要的农业行星，供应着周边星系的粮食，但因为繁琐的帝国官僚制度，这里的市场价格充满了漏洞。 

​		在这个世界里，麦格隆 IV 的**粮食磨坊**以每袋面粉p金币的价格出售大量面粉，而星球另一端的**战锤酒馆**（一处为帝国军官和工兵提供休憩的地方）愿意以每袋qqq金币（q>p）的高价回收面粉，用于酿造他们特制的“酥麦酒”。这是一个无本生利的绝佳机会。 

​		然而，事情并不简单。帝国的行星交通管理混乱，运输耗时且费用高昂。如果 苏向夜 想一次性从磨坊购买xxx袋面粉，他需要付px金币，ax+b秒的运输时间 

​	

​		同样地，如果 苏向夜 想一次性向酒馆出售x袋面粉，他可以赚qx金币但需要花费cx+d秒的时间 

​		此时，苏向夜 的金币数量是 m，但 **苏向夜** 马上就要参加一场重大的帝国测评考试——这将决定他是否能够摆脱走私身份，成为正式的帝国公民。他只有t秒的时间可以用来完成这次走私行动。 

​		现在，苏向夜 想知道，在t 秒时间用尽之后，他最多能够拥有多少金币。这是一次与时间和运气的博弈——既要在磨坊与酒馆之间奔波，又要小心不要浪费时间，以免错过帝国考试。

#### 输入描述

有多组测试数据，第一行输入一个整数T(1<=T<=500),表示测试数据组数

对于每一组测试数据：
$$
\begin{flalign*}
\begin{split}
第一行三个&整数p,a,b(1<=p,a<=10^9,0<=b<=10^9)\\

第二行三个&整数q,c,d(p<q<=10^9,1<=c<=10^9,0<=d<=10^9)\\

第三行两个&整数m,t(1<=m,t<=10^9)
\end{split}&
\end{flalign*}
$$


#### 输出描述

$$
每组数据输出一行一个整数，表示苏向夜在t秒后最多持有多少金币
$$

#### 用例输入 1



```cpp
1
5 2 3
8 1 5
14 36
```



#### 用例输出 1



```cpp
32
```

#### 说明

xx首先在磨坊买2袋面粉，花费2*2+3=7秒以及5\*2=10金币。然后他把所有买的面粉卖给酒馆，花费1*2+5=7秒但赚取8*2=16金币，现在xx有20金币，还剩22秒。
接下来买4袋面粉，然后全部卖给酒馆，最终xx有32个金币。

### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
using namespace std;
int T;
signed main()
{
    cin >> T;
    while (T--)
    {
        int p, a, b; // 花px金币购买，ax+b时间运输
        int q, c, d; // 以qx金币出售，cx+d时间收取
        cin >> p >> a >> b >> q >> c >> d;
        int m, t; // 初始的金币数m，时间t
        cin >> m >> t;
        int max_x = m / p; // 此时能购买的最大数量

        int time1 = a * max_x + b;
        int time2 = c * max_x + d;

        while (1)
        {
            if (t >= time1 + time2 && max_x > 0)
            {
                t -= time1 + time2;
                m -= p * max_x;
                m += q * max_x;
                max_x = m / p;
            }
            else if (max_x > 0 || t < time1 + time2)
            {
                max_x--;
            }
            else
            {
                break;
            }
            time1 = a * max_x + b;
            time2 = c * max_x + d;
        }
        cout << m << endl;
    }
}
```



### 解题思路：

这个题涉及到一个时间的取舍，但显然的是，对于相同的x，一定是买的越多，节约时间越多，原因如下：
$$
\begin{flalign*}
\begin{split}
&如果有 1 \le m \le x，时间都充足的情况下：\\
&a(x-m)+b + am+b \ge ax+b \\ &\text{这是显然成立的，}\\
&也就是说，在时间足够的情况下，一次买的越多，才可能卖的越多.\\
&因为这是最节约时间的做法\\
&因此每次都应该以本金为基础计算最大可以买的数量。\\
&对比时间是否充足，如果不充足就减少数量直至时间足够。
\end{split}&
\end{flalign*}
$$


#### 问题与反思：

1.题干太长了，看着好像很复杂，但实际主要是考虑赚钱效率，在这里我们可以将效率抽象为(p-q)x/(a+c)x+b+d，分子分母同时除以x，可以知道效率是在x越大的情况下，分母越小，在这种情况下，效率更高。可以类似的得出上面的结论即在时间和钱都充足的情况下，每次都要尽可能花费更多时间或者本金，才可能赚更多的钱

### 十二：编辑器



### 题目链接：[[L-编辑器_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/L)]



#### 题目描述：

需要计算一些特殊数据的syx，由于需要赶工其他事情来不及耐下心来思考如何去计算这些数据，于是他将问题交给了你。 

​		你需要实现一个功能强大的整数序列编辑器。 

​		在开始时，序列是空的。

1、`I x`，在光标处插入数值xxx。
2、`D`，将光标前面的第一个元素删除，如果前面没有元素，则忽略此操作。
3、`L`，将光标向左移动，跳过一个元素，如果左边没有元素，则忽略此操作。

4、`R`，将光标向右移动，跳过一个元素，如果右边没有元素，则忽略此操作。

#### 输入描述

第一行包含一个整数 q
$$
1 \le q \le 10^6
$$
表示指令的总数。

接下来 q 行，每行一个指令，具体指令格式如题目描述。

| x | ≤ 10 ^3,1≤k≤n

#### 输出描述

对于每一个 Q k指令，输出一个整数作为结果，每个结果占一行。

#### 用例输入 1



```cpp
8
I 2
I -1
I 1
Q 3
L
D
R
Q 2
```



#### 用例输出 1



```cpp
2
3
```



### 解题代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e6+10;
  
int q;
int stkl[maxn],stkr[maxn],tl,tr;
ll s[maxn],f[maxn];
  
int main(){
    scanf("%d",&q);
    f[0]=INT_MIN;
    while(q--){
        getchar();
        char c;
        c=getchar();
        if(c=='I'){
            int x;
            scanf("%d",&x);
            stkl[++tl]=x;
            s[tl]=s[tl-1]+x;
            f[tl]=max(s[tl],f[tl-1]);
        }else if(c=='D'){
            if(tl>0)    tl--;
        }else if(c=='L'){
            if(tl>0){
                stkr[++tr]=stkl[tl];
                tl--;
            }
        }else if(c=='R'){
            if(tr>0){
                stkl[++tl]=stkr[tr];
                s[tl]=s[tl-1]+stkr[tr];
                f[tl]=max(s[tl],f[tl-1]);
                tr--;
            }
        }else{
            int k;
            scanf("%d",&k);
            printf("%lld\n",f[k]);
        }
    }
    return 0;
}

```



### 解题思路：

这里我们使用两个栈，用栈与栈之间的空间来充当题目中"光标"，另外因为在这里我们要求一个最大的前面的和，我们可以很自然的想到前缀和的思路，只要我们时刻记录到目前"光标"位置的最大值即可，在这里我们是通过插入中的`s[tl]=s[tl-1]+x;f[tl]=max(s[tl],f[tl-1]);`和`s[tl]=s[tl-1]+stkr[tr];f[tl]=max(s[tl],f[tl-1]);`来进行实时的更新。

在前缀和数组的影响之下，这个题用数组模拟栈反而更加具有优势了，因为数组的`idx`索引是和数组元素个数紧密关联的，可以更好的管理前缀和数组。

#### 问题与反思：

1.虽然cpp带有`stack`的容器，但在这里的灵活性确实要稍差一些

2.使用前缀和数组是为了降低查询的时间复杂度

### 十三：切多边形(数学规律)



### 题目链接：[[M-切多边形_第十六届西南石油大学程序设计新生赛](https://ac.nowcoder.com/acm/contest/98528/M)]



#### 题目描述：

在一片魔法大陆上，有一座名为“**几何秘境**”的奇迹之地，这里隐藏着传说中的“碎片之钥”，据说它能打开任何封印的宝箱。然而，要获得这把钥匙，冒险者必须通过一道考验——**几何分割试炼**。

​	几何秘境中央漂浮着一个由 n 个顶点组成的魔法正多边形，每个顶点都散发着耀眼的光芒。秘境的守护者提出了一个挑战：选择一个整数 k，然后按照以下规则施展“连线魔法”：

​	从顶点 i （ i = 0 , 1 , … , n − 1 ）发射一条魔法光线，连接到顶点 ( i + k )  mod  n 。

​	当所有的魔法光线完成后，多边形会被这些光线分割成若干块区域。守护者要求冒险者计算出最终可以分割出的区域数量，只有准确回答才能通过试炼，获得“碎片之钥”。

​	传说中，只有真正理解几何魔法奥秘的冒险者，才能破解这道难题。你是否能用智慧，征服这道试炼？

#### 输入描述



唯一的一行包含 2个整数n, k（4≤n≤10^6,2≤k≤n−2），分别表示正多边形的边数和选择的整数。

#### 输出描述

输出一个整数，表示最终的块数

#### 用例输入 1



```cpp
6 2 
```



#### 用例输出 1



```cpp
13
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
#define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
#define DG(x) cout << #x << " = " << x << endl;

#define MAXN 100005
using namespace std;
int n, k;
int process(int n, int k)
{
    if(k>n-k) k=n-k;
    if(k==n/2 && !n%2) return n;
    return n * k + 1;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k;
    cout << process(n, k);
    return 0;
}

```



### 解题思路：

1.从某种角度来说就是找规律：

1) 存在一个对称性 k和n-k在实质上是等价的
2) 存在k=n/2的一个特殊情况

2.实际的解析涉及到欧拉公式如下：

![image-20241215200839075](C:\Users\17383\AppData\Roaming\Typora\typora-user-images\image-20241215200839075.png)

$$
(搬运自知乎，作者如图)
$$

#### 问题与反思：











