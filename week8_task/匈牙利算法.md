### 一：二分图的最大匹配

### 题目链接：[[861. 二分图的最大匹配 - AcWing题库](https://www.acwing.com/problem/content/863/)]



#### 题目描述：

给定一个二分图，其中左半部包含 n1 个点（编号 1∼n1），右半部包含 n2 个点（编号 1∼n2），二分图共包含 m 条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图 G，在 G的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数

#### 输入描述

第一行包含三个整数 n1、 n2 和 m。

接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。

#### 输出描述

输出一个整数，表示二分图的最大匹配数。

#### 用例输入 1



```
2 2 4
1 1
1 2
2 1
2 2
```



#### 用例输出 1



```
2
```



### 解题代码：



```cpp
#include <bits/stdc++.h>
// #define int long long
#define Ir(i, a, b) for (int i = a; i < b; i++)
#define Ip(i, a, b) for (int i = a; i <= b; i++)
#define F(a, ch) for (auto a : ch)
#define DG(x) cout << #x << " = " << x << endl;

#define MAXN 100005
using namespace std;
const int N = 510 , M = 100010;
int h[N] , e[M], ne[M],idx;
int n1,n2,m;        
int a,b;
bool st[N];
int matp[N];

void add(int a,int b){
    e[idx] = b , ne[idx] = h[a] , h[a] = idx ++ ;
}


int find(int x){
    for(int i = h[x]; ~i; i = ne[i]){
        int j = e[i];
        if(!st[j]){
            st[j] = true;
            if(!matp[j] || find(matp[j])){
                matp[j] = x;
                return true;
            }
        }
    }
    return false;
}

signed main() {
    memset(h,-1,sizeof(h));
    
    cin >> n1 >> n2 >> m;
    while (m--){
        cin >> a >> b;
        add(a,b);
    }
    
    int ans = 0;    
    Ip(i,1,n1){
        memset(st,false,sizeof(st));
        if(find(i)) ans++;
    }
    
    cout << ans << endl;
    return 0;
}

```



### 解题思路：

1) 匈牙利算法主要是这样，首先对于一个图集`G`，在这里我们在输入上保证这是一个二分图，可以分为`A` `B`,如果对于`A`中的一个顶点`A_1`，它与`B`中的某一个顶点`B_1`相连，如果`B`中的这个顶点，1)没有其他路径，这是一个匹配，如果`B`中的这个顶点还有其他路径，并且这个路径的另一个顶点`A_2`(是不同于前文的`A`的某一顶点)，存在一个不同于前文的`B`的顶点`B_2`形成路径，那么我们认为`A_1`和`B_1`形成匹配，`A_2`和`B_2`形成匹配。
2) 在这里出于稀疏图的考虑我们使用邻接表的方式存储图
3) 我们在这里主要有两层遍历，第一层是挑选哪个点作为起始点，这样能够保证我们考虑到所有的情况，挑选初始点以后我们进入`find`函数，在`find`函数中进行进一步遍历，如果这条边没有被访问过，那我们就先访问即`if(!st[j]) st[j] = true;`，并且如果这个点不在另一个集合中(即是未匹配的状态)，或者说能够递归的为这个`j`的匹配点找到一个新的匹配点(即是`find(matp[j] == true`)，那么就更新这个匹配状态(具体更新情况在上文已经提及)
4) 以上，对于每个结点都做相同操作以后 得到ans即为最大匹配数量

#### 问题与反思：

1. 在这里主要是有一个递归的使用，因为如果说A_1的端点B_1已经形成匹配，那么我们就需要对这个B_1进行处理，看他有没有未形成的匹配，如果有就更新。但如果很不幸的B_1的端点也已经形成匹配，那么B_1就变成了上文的A_1，这就是程序的递归所在

    > 我们存储图使用的是`add(a,b)而没有再使用add(b,a)`,这使得我们不会出现走回头路的情况，尽管本身这是一个无向图

