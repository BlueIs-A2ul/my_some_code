### 一：单调栈



### 题目链接：[[830. 单调栈 - AcWing题库](https://www.acwing.com/problem/content/832/)]



#### 题目描述：

给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。



#### 输入描述

第一行包含整数 N，表示数列长度。

第二行包含 N 个整数，表示整数数列。

#### 输出描述

共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 -1。

#### 用例输入 1

```
5
3 4 2 7 5
```

#### 用例输出 1

```
-1 3 -1 2 2
```

### 解题代码：



```cpp
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    int n;
    cin >> n;
    stack<int> stk;

    while (n--)
    {
        int x;
        scanf("%d", &x);

        while (!stk.empty() && stk.top() >= x)
        {
            stk.pop();
        }

        if (stk.empty())
            printf("-1 ");
        else
            printf("%d ", stk.top());
        stk.push(x);
    }

    return 0;
}
```



### 解题思路：

本身应该可以直接遍历，在最差情况下的时间复杂度应该是O(n^2)，然而用栈可以优化到O(n)，因为实际上只需要遍历一次，我们在栈里储存的是当下的元素左侧的第一个最小的元素，如果当前元素比栈顶还要小，那么就栈顶就出栈，直到栈顶元素足够小或空栈。

#### 问题与反思：

1.能不能用动态规划达到相似的效果呢，创建一个新的数组用以记录这个左侧第一个最小的数字。

