### 一：排列数字



### 题目链接：[[842. 排列数字 - AcWing题库](https://www.acwing.com/problem/content/844/)]



#### 题目描述：

给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。(是一种用于排列单词或字符串的顺序规则。这种顺序基于字母表中的顺序，从左到右逐个字符地进行比较。)

#### 输入描述

共一行，包含一个整数 n。

#### 输出描述

按字典序输出所有排列方案，每个方案占一行。

#### 用例输入 1



```
3
```



#### 用例输出 1



```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```



### 解题代码：



```cpp
#include <iostream>
using namespace std;

const int N = 100;
int n;
int path[N];//保存排列，当长度到达时输出
bool st[N];//记录数字是否被使用
//dfs(u)表示在第u个位置进行操作
void dfs(int u){
    if(u==n){
        for(int i=0;i<n;i++){
            cout<<path[i]<<" ";
        }
        cout<<endl;
        return;
    }

    for(int i=1;i<=n;i++){
        if(!st[i] ){
            path[u]=i;
            st[i]=true;
            dfs(u+1);//迭代到下一层

            st[i]=false;
            path[u]=0;//实际可以不写
        }
    }
}

int main() {
    cin>>n;
    dfs(0);
    return 0;
    }
    

```



### 解题思路：

作为深度优先搜索(dfs)的题目，这个题主要涉及到几个点：首先是如何在排列完毕后进行输出，我们是利用path[]数组和dfs函数本身调用的u来进行控制，path[]记录数字的排列，u用以记录层数，层数到达即排列完毕可以输出。

然后是如何避免数字重复的情况，在这里我们使用st[]的bool数组，如果某个数字已经被使用就命其为true，再结合if( !st[i] )，这样就不会在迭代过程中，将已经被使用过的数字赋值到path[]数组中。

#### 问题与反思：

1.这个代码的运行对回溯算法的体现不是很完全，实际是相对割裂的一个过程，更多的倾向于迭代和递归的过程实践。

